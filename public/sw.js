// SSA Manager Service Worker
// Compatible with OneSignal Push Notifications
// Uses Workbox for precaching and runtime caching
// NOTE: OneSignal SDK is NOT imported here - OneSignal manages its own service worker (OneSignalSDKWorker.js)

import { precacheAndRoute, cleanupOutdatedCaches } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import {
  NetworkFirst,
  CacheFirst,
  StaleWhileRevalidate,
} from "workbox-strategies";
import { CacheableResponsePlugin } from "workbox-cacheable-response";
import { ExpirationPlugin } from "workbox-expiration";

// Precache all assets generated by the build process
// This will be replaced by Workbox with the actual manifest
precacheAndRoute(self.__WB_MANIFEST);

// Clean up outdated caches
cleanupOutdatedCaches();

const RUNTIME_CACHE = "ssa-runtime-v1";

// OneSignal URLs - don't intercept these
const ONESIGNAL_PATTERNS = [/onesignal\.com/i, /OneSignalSDK/i];

/**
 * Check if request is for OneSignal
 */
function isOneSignalRequest(url) {
  return ONESIGNAL_PATTERNS.some((pattern) => pattern.test(url));
}

// Skip waiting and claim clients immediately
self.addEventListener("install", (event) => {
  console.log("[SW] Installing service worker...");
  self.skipWaiting();
});

self.addEventListener("activate", (event) => {
  console.log("[SW] Activating service worker...");
  event.waitUntil(self.clients.claim());
});

// Custom fetch handler to skip OneSignal requests
self.addEventListener("fetch", (event) => {
  const { request } = event;
  const url = request.url;

  // Skip OneSignal requests - let OneSignal handle them
  if (isOneSignalRequest(url)) {
    return;
  }

  // Let Workbox handle other requests through registered routes
});

// Register runtime caching routes using Workbox strategies
// API requests - Network first with cache fallback
registerRoute(
  ({ url }) =>
    url.pathname.includes("/api/") || url.hostname.includes("supabase.co"),
  new NetworkFirst({
    cacheName: "api-cache",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
      }),
    ],
  })
);

// Google Fonts - Cache first
registerRoute(
  ({ url }) =>
    url.origin === "https://fonts.googleapis.com" ||
    url.origin === "https://fonts.gstatic.com",
  new CacheFirst({
    cacheName: "google-fonts",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// CDN resources - Stale while revalidate
registerRoute(
  ({ url }) => url.origin === "https://cdn.jsdelivr.net",
  new StaleWhileRevalidate({
    cacheName: "cdn-cache",
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

/**
 * Message Event - Handle messages from clients
 */
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});

/**
 * Push Event - Handle push notifications (if not using OneSignal)
 * Note: OneSignal handles push events through OneSignalSDKWorker.js
 */
self.addEventListener("push", (event) => {
  console.log("[SW] Push event received:", event);
  // OneSignal handles push notifications, but we keep this for fallback
  if (event.data) {
    const data = event.data.json();
    const options = {
      body: data.body || "New notification",
      icon: "/icon-192.png",
      badge: "/icon-96.png",
      data: data.data || {},
    };
    event.waitUntil(
      self.registration.showNotification(data.title || "SSA Manager", options)
    );
  }
});

/**
 * Notification Click Event
 */
self.addEventListener("notificationclick", (event) => {
  console.log("[SW] Notification clicked:", event);
  event.notification.close();

  const urlToOpen = event.notification.data?.url || "/";

  event.waitUntil(
    clients
      .matchAll({ type: "window", includeUncontrolled: true })
      .then((windowClients) => {
        // Check if there's already a window open
        for (let client of windowClients) {
          if (client.url === urlToOpen && "focus" in client) {
            return client.focus();
          }
        }
        // Open new window if none exists
        if (clients.openWindow) {
          return clients.openWindow(urlToOpen);
        }
      })
  );
});

console.log("[SW] Service Worker loaded successfully");
